<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code with Kira</title>
  <link href="https://codewithkira.com/atom.xml" rel="self"/>
  <link href="https://codewithkira.com"/>
  <updated>2025-03-04T00:58:14+00:00</updated>
  <id>https://codewithkira.com</id>
  <author>
    <name>Kira McLean</name>
  </author>
  <entry>
    <id>https://codewithkira.com/2025-02-26-making-data-useful.html</id>
    <link href="https://codewithkira.com/2025-02-26-making-data-useful.html"/>
    <title>Making data useful</title>
    <updated>2025-02-26T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p><img src="/assets/profit.jpg" alt="How do we turn messy data into profit?" /></p><p>Making data useful is difficult. The whole point of data engineering/science/analysis/etc is to turn all of the endless piles of information we collect into <i>something</i> that people find valuable. I've spent the better part of the last decade in my career as a software engineer building systems that do this, and I've noticed that it is remarkably difficult to do well. There are many points where the process breaks down, and no silver bullet for fixing them. I've spent a lot of time trying to organize my thoughts on the topic and wrote this down one night:</p><p><img src="/assets/pipeline.jpg" alt="Turning chaotic and unorganized information into useful insights" /></p><p>This is one path that the piles of chaotic information we hoard can take to become useful. One problem is that executing all of these steps well requires at minimum a software engineer, a data scientist, and a business analyst.</p><p>Without an engineer your data pipelines will be unreliable and incorrect, without a data scientist your analysis will be misleading, and without a business analyst the results will be meaningless and never reach the people who need to see them. That's easily $0.5M/year in headcount alone, a huge expense even if you manage to find a team of open source superstars who can do all of this with free tools and minimal infrastructure.</p><p>Another problem is that the steps along this path are not neatly delineated in any way, making them hard to outsource or share. You need the whole team working closely together start to finish to clear a path for your data to flow through the organization.</p><ul><li>A software/data engineer understands how to extract, organize, transform, and store data, but doesn't have a clue what it means. They need input from the business analyst on day one to understand <em>which</em> data should be extracted, and input from the data scientist to understand what format and storage solution will be most convenient for their use. Then they need to come back at the end of the process and help with distribution and dissemination, shipping dashboards, apps, reports, and other ways for non-technical end-users to actually see the results.</li><li>The data scientist needs help from the software engineer to understand why the incoming data is incomplete, inaccurate, and out of date. They need their buy-in to help increase the data's quality, and their help to implement observability and quality checks in a way that isn't slow and expensive. Then once they have clean datasets (no small feat), they need input from the business analyst to understand what they should be looking for.</li><li>The business analyst needs to be giving input every step of the way to make sure the right data gets collected in the first place all the way through to seeing that the right reports are delivered to the right people. They also need to explain the domain and context to their more technical teammates to make sure what they're building is actually valuable to the organization.</li></ul><p>There are tools that can help make some of this smoother, but it's a fundamentally complex problem to optimize in a cost-effective way. It's really interesting to think through where the pain points are, and how technology can help address them. This is what's taking up a lot of my bandwidth lately, so if any of it resonates with you I'd love to chat sometime!</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-12-31-clojurists-together-update-nov-dec-2024.html</id>
    <link href="https://codewithkira.com/2024-12-31-clojurists-together-update-nov-dec-2024.html"/>
    <title>OSS Updates November and December 2024</title>
    <updated>2024-12-31T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>This is a summary of the open source work I spent my time on throughout November and December 2024. This was the last period of my ongoing funding from Clojurists together. It's been such a magical year in many ways and I'm so grateful to have had the opportunity to spend so much time focusing on open source this year. It was a fantastic experience and I hope to be able to take another professional hiatus at some point in the future to do it again.</p><p>I've really enjoyed writing these summaries, too, and I find knowing they're coming helps motivate me to stay more organized and keep better track of things, so I'll probably continue to publish them even though I'll be spending less time on side projects as my focus shifts to other priorities this year.</p><h2 id="sponsors">Sponsors</h2><p>I always start these posts with a sincere thank you to the generous ongoing support of my sponsors that make this work possible. I can't say how much I appreciate all of the support the community has given to my work and would like to give a special thanks to Clojurists Together and Nubank for providing incredibly generous grants that allowed me reduce my client work significantly and afford to spend more time on projects for the Clojure ecosystem for nearly a year.</p><p>If you find my work valuable, please share it with others and consider supporting it financially. There are details about how to do that on my <a href='https://github.com/sponsors/kirahowe'>GitHub sponsors page</a>. On to the updates!</p><h2 id="bobkonf&#95;2025">BOBKonf 2025</h2><p>One exciting update is that <a href='https://bobkonf.de/2025/howe.html'>a workshop I proposed got accepted to BOBKonf</a>, which will be in Berlin next March. It'll be similar to the types of talks and workshops I've been doing over the last couple of years at e.g. the Conj and London Clojurians, of course updated to show off the latest and greatest developments in the Clojure-for-data ecosystem. I spent some time in December beginning work on the content and now I'm in full conference-driven-development mode, figuring out what's realistic to finish in time to demo at the event and what we should consider stable "enough" for now and just include. This preliminary work also sparked a couple of minor conversations, one about <a href='https://github.com/scicloj/clay/issues/192'>quarto theming of Clay notebooks</a> and another about <a href='https://clojurians.zulipchat.com/#narrow/channel/236259-tech.2Eml.2Edataset.2Edev/topic/excel.20dates/near/486781881'>parsing dates from Excel workbooks</a>.</p><p>Anyway there are still a couple of months to work on it, which on one hand feels like a long time but on the other hand is also no time at all. Before I know it I'll be landing in Berlin ready to share the wonders of Clojure with a new eager audience.</p><h2 id="clojure&#95;data&#95;cookbook">Clojure Data Cookbook</h2><p>This has been a very long-running, very ongoing project of mine. The high level goal was always (and still is) to create resources that would allow people to figure out how to be productive with Clojure's data stack. In reality what this particular project morphed into was a process for discovering the gaps in the ecosystem and guiding development of new tools, uncovering missing features to implement or new libraries to write every time I'd start work on a new chapter.</p><p>We've come a long way over the past couple of years and there's still work to do but the ecosystem is reasonably mature now. The <a href='https://scicloj.github.io/noj/'>Noj book</a> has taken on covering a lot of the topics I wanted to document thanks to Daniel Slutsky's incredible efforts at coordinating the community to produce this amazing content. The list of draft articles demonstrates many of the areas where work is still very ongoing in the development of the various libraries. Tutorials are mostly not left unfinished because the authors haven't gotten around to finishing them, but more because the question of what exactly to write about is yet to be answered.</p><p>On the Clojure Data Cookbook itself, the current work in progress is <a href='https://scicloj.github.io/clojure-data-cookbook/'>available here</a> and includes only sections that document stable and established functionality. The goal of making Clojure's data stack accessible and easy to work with is still at the top of my priority list but conversations are underway about what the best way to do that is in the context of the current ecosystem.</p><h2 id="ggclj">ggclj</h2><p>Another project I've been poking away at the last couple of months is my implementation of the <a href='https://github.com/kirahowe/ggclj'>grammar of graphics in Clojure</a>. Most of my effort here is spent learning more and more about the core concepts of data visualization and how graphics can be represented using a grammar, and then how that grammar could be implemented in an existing programming language. This along with exploring prior implementations in other languages. I have a very rudimentary build process working for transforming an arbitrary dataset into a standardized, graph-able dataset, but nothing yet on the actual graphic rendering. It's very interesting and satisfying but I'm not sure how useful. But, in the spirit of heeding Rich's advice from the last Conj about doing projects for fun, I haven't let it go completely. It's still something I'd love to get working someday.</p><h2 id="reflecting&#95;on&#95;a&#95;year&#95;of&#95;open&#95;source">Reflecting on a year of open source</h2><p>As I mentioned above I really enjoyed having the time this year to work on so many interesting projects for the Clojure community. It's so rewarding to see how far we've come. Even though it feels like there is still so much to do, I think it's important to reflect on the progress we have made and think about how the problems we encountered along the way shaped the path we took.</p><p>When I first started working on the Clojure Data Cookbook, there wasn't even a way to publish a book made out of Clojure files. Clerk was brand new and Clay barely existed. Now we can render a pile of Clojure files as a Quarto book! And the need for better documentation has spurred tons of amazing development in this space. The literate programming story in Clojure is better than in any other language.</p><p>We've also made huge strides in connecting the various libraries of the ecosystem together. At the beginning of the year there were many amazing but disconnected libraries. I've been really inspired by the ideas behind the tidyverse and have been trying to communicate the idea of sharing common idioms and data structures. An ecosystem is starting to emerge in Noj that offers a coherent, standardized, shared paradigm for using all of the amazing tools of the Clojure data ecosystem together. The default stack has been chosen, and serious efforts are now underway toward making these libraries feature complete and interoperable. And I plan to continue working on tutorials, guides, and workshops as much as I can to help promote it all. </p><p>I'm grateful for all the changes in my life that have taken my time away from working on side projects as much as I used to, like marriage and a great new job, but in many ways I miss doing more of this work and I sincerely hope I find myself in a position to veer off of this "standard" life track in the future to take a period to focus on this kind of stuff full time again. Even better would be figuring out a way to make it sustainable so that I could continue to do it full time. If you have any idea  how to make that work, let me know :)</p><p>It turns out I am not the kind of market-oriented, entrepreneurially-minded person who can turn coding skills into a business that generates steady income for my family. I like contracting and the slow-and-steady community building type of work that constitutes a career in open source, but unfortunately continuing down this road is just not in the cards for me this year. Though I'll never be able to completely resist working on it whenever I can :) Thanks so much for reading this far, and hope to see you around the Clojureverse!</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-10-31-clojurists-together-update-sept-oct-2024.html</id>
    <link href="https://codewithkira.com/2024-10-31-clojurists-together-update-sept-oct-2024.html"/>
    <title>OSS Updates September and October 2024</title>
    <updated>2024-10-31T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>This is a summary of the open source work I spent my time on throughout September and October 2024. This was a very busy period in my personal life and I didn't make much progress on my projects, but I did have more time than usual to think about things, which prompted many further thoughts. Keep reading for details :)</p><h2 id="sponsors">Sponsors</h2><p>I always start these posts with a sincere thank you to the generous ongoing support of my sponsors that make this work possible. I can't say how much I appreciate all of the support the community has given to my work and would like to give a special thanks to Clojurists Together and Nubank for providing incredibly generous grants that allowed me reduce my client work significantly and afford to spend more time on projects for the Clojure ecosystem for nearly a year.</p><p>If you find my work valuable, please share it with others and consider supporting it financially. There are details about how to do that on my <a href='https://github.com/sponsors/kirahowe'>GitHub sponsors page</a>. On to the updates!</p><h2 id="personal&#95;update">Personal update</h2><p>I'll save the long version for the end but there is one important personal update that's worth mentioning up front: I go by Kira Howe now. I used be known as Kira McLean, and all of my talks, writing, and commits up to this point use Kira McLean, but I'm still the same person! Just with a new name. I even updated my <a href='https://github.com/kirahowe'>GitHub handle</a>, which went remarkably smoothly.</p><h2 id="conj&#95;2024">Conj 2024</h2><p>The main Clojure-related thing I did during this period was attend the Conj. It's always cool to meet people in person who you've only ever worked with online, and I finally got to meet so many of the wonderful people from Clojure Camp and Scicloj who I've had the pleasure of working with virtually. I also had the chance to meet some of my new co-workers, which was great. There were tons of amazing talks and as always insightful and inspiring conversations. I always leave conferences with tons of energy and ideas. Then get back to reality and realize there's no time to implement them all :) But still, below are some of the main ideas I'm working through after a wonderful conference.</p><h2 id="svgs&#95;for&#95;visualizing&#95;graphics">SVGs for visualizing graphics</h2><p>Tim Pratley and Chris Houser gave a fun talk about SVGs, among other things, that made me realize using SVGs might be the perfect way to implement the "graphics" side of a grammar of graphics.</p><p>Some of you may be following the development of <a href='https://github.com/scicloj/tableplot'>tableplot</a> (formerly hanamicloth), in which Daniel Slutsky has been implementing an elegant, layered, grammar-of-graphics-inspired way to describe graphics in Clojure. This library takes this description of a graphic and translates it into a specification for one of the supported underlying Javascript visualization libraries (currently vega-lite or plotly, via hanami). Another way to think about it is as the "grammar" part of a grammar of graphics; a way to declaratively transform an arbitrary dataset into a standardized set of instructions that a generic visualization library can turn into a graphic. This is the first half of what we need for a pure Clojure implementation of a grammar of graphics.</p><p>The second key piece we need is a Clojure implementation of the actual graphics rendering. Whether we adopt a similar underlying representation for the data as vega-lite, plotly, or whatever else is less consequential at this stage. Currently we just "translate" our Clojure code into vega-lite or plotly specs and call it a day. What I want to implement is a Clojure library that can take some data and turn it into a visualization. There are many ways to implement such a thing, all with different trade-offs, but Tim and Chouser's talk made me realize SVGs might be a great tool for the job. They're fast, efficient, simple to style and edit, plus they offer potentially the most promising avenues toward making graphics accessible and interactive since they're really just XML, which is semantic, supports ARIA labels, and is easy to work with in JS.</p><p>Humble UI also came up in a few conversations, which is a totally tangential concern, but it was interesting to start thinking about how all of this could come together into a really elegant, fully Clojure-based data visualization tool for people who don't write code.</p><h2 id="a&#95;clojurey&#95;way&#95;of&#95;working&#95;with&#95;data">A Clojurey way of working with data</h2><p>I also had a super interesting conversation on my last night in Alexandria about Clojure's position in the broader data science ecosystem. It's fair to say that we have more or less achieved feature parity now for all the essential things a person working with data would need to do. Work is ongoing organizing these tools into a coherent and accessible stack (see <a href='https://scicloj.github.io/noj/'>noj</a>), but the pieces are all there.</p><p>The main insight I left with, though, was that we shouldn't be aiming for mere feature parity. It's important, but if you're a working data scientist doing everything you already do just with Clojure is only a very marginal improvement and presents a very high switching cost for potentially not enough payoff. In short, it's a tough sell to someone who's doesn't already have some prior reason to prefer Clojure.</p><p>What we should do is leverage Clojure's strengths to build tools that could leapfrog the existing solutions, rather than just providing better implementations of them. I.e. think about new ways to solve the fundamental problems in data science, rather than just offering better tools to work within the current dominant paradigm.</p><p>For example, a fundamental problem in science is reproducibility. The current ways data is prepared and managed in most data (and regular) science workflows is madness, and versioning is virtually non-existent. If you pick up any given scientific paper that does some sort of data analysis, the chances that you will be able to reproduce the results are near zero, let alone using the same tools the author used. If you do manage to, you will have had to use a different implementation than the authors, re-inventing wheels and reverse-engineering their thought process. The problem isn't that scientists are bad at working with data, it's the fundamental chaos of the underlying ecosystem that's impossible to fight.</p><p>If you've ever worked with Python code, you know that dependency management is a nightmare, never mind state management within a single program. Stateful objects are just a bad mental model for computing because they require us to hold more information in our heads in order to reason about a system than our brains can handle. And when your mental model for a small amount of local data is a stateful, mutable thing, the natural inclination is to scale that mental model to your entire system. Tracking data provenance, versions, and lineage at scale is impossible when you're thinking about your problem as one giant, mutable, interdependent pile of unorganized information.</p><p>Clojure allows for some really interesting ways of thinking about data that could offer novel solutions to problems like these, because we think of data as immutable and have the tools to make working with such data efficient. None of this is new. Somehow at this Conj between some really interesting talks focused on ways of working with immutable data and subsequent conversations it clicked for me, though. If we apply the same ways we think about data in the small, like in a given program, more broadly to an entire system or workflow, I think the benefits could be huge. It's basically implementing the ideas from <a href='https://www.youtube.com/watch?v=-6BsiVyC1kM'>Rich Hickey's "Value of values"</a> talk over 10 years ago to a modern data science workflow. </p><p>Other problems that Clojure is well-placed to support are:</p><ul><li>Scalability &ndash; Current dominant data science tools are slow and inefficient. People try to work around it by implementing libraries in C, Rust, Java, etc. and using them from e.g. Python, but this can only get you so far and adds even more brittleness and dependency management problems to the mix.</li><li>Tracking data and model drift &ndash; This problem has a very similar underlying cause as the reproducibility issue, also fundamentally caused by a faulty mental model of data models as mutation machines.</li><li>Testing and validation &ndash; Software engineering practices have not really permeated the data science community and as such most pipelines are fragile. Bringing a values-first and data-driven paradigm to pipeline development could make them much more robust and reliable.</li></ul><p>Anyway I'm not exactly sure what any of this will look like as software yet, but I know it will be written in Clojure and I know it will be super cool. It's what I'm thinking about and experimenting with now. And I think the key point that thinking about higher-level problems and how Clojure can be applied to them is the right path toward introducing Clojure into the broader data science ecosystem.</p><h2 id="software&#95;engineers&#95;as&#95;designers">Software engineers as designers</h2><p>Alex Miller's keynote was all about designing software and how they applied a process similar to the one described in <a href='https://www.youtube.com/watch?v=c5QF2HjHLSE'>Rich Hickey's keynote from last year's conj</a> to Clojure 1.12 (among other things). The main thing I took away from it was that the best use of an experienced software engineer's time is not programming. I've had the good fortune of working with a lot of really productive teams over the years, and this talk made me realize that one thing the best ones all had in common is that at least a couple of people with a lot of experience were not in the weeds writing code all the time. Conversely a common thread between all of the worst teams I've been a part of is that team leads and managers were way too in the weeds, worrying too much about implementation details and not enough about what was being implemented.</p><p>I've come to believe that it's not possible to reason about systems at both levels simultaneously. My brain at least just can't handle both the intense attention to detail and very concrete, specific steps required to write software that actually works and the abstract, general conceptual type of thinking that's required to build systems that work. The same person can do both things at different times, but not at the same time, and the cost of switching between both contexts is high.</p><p>Following the process described by Rich and then Alex is a really great way to add structure and coherence to what can otherwise come across as just "thinking", but it requires that we admit that writing code is not always the best use of our time, which is a hard sell. I think if we let experienced software engineers spend more time thinking and less time coding we'd end up with much better software, but this requires the industry to find better ways to measure productivity.</p><h2 id="long&#95;version&#95;of&#95;personal&#95;updates">Long version of personal updates</h2><p>As most of you know or will have inferred by now, I got married in September! It was the best day ever and the subsequent vacation was wonderful, but it did more or less cancel my productivity for over a month. If you're into weddings or just want a glimpse into my personal life, we had a reel made of our wedding day that's available <a href='https://www.instagram.com/reel/C__5_r9pAea/'>here on instagram via our wedding coordinator</a>.</p><p>Immediately after I got back from my honeymoon I also started a new job at BroadPeak, which is going great so far, but also means I have far less time than I used for open source and community work. I'm back to strictly evening and weekend availability, and sadly (or happily, depending how you see it) I'm at a stage of my life where not all of that is free time I can spend programming anymore.</p><p>I appreciate everyone's patience and understanding as I took these last couple of months to focus on life priorities outside of this work. I'm working on figuring out what my involvement in the community will look like going forward, but there are definitely tons of interesting things I want to work on. I'm looking forward to rounding out this year with some progress on at least some of them, but no doubt the end of December will come before I know it and there will be an infinite list of things left to do.</p><p>Thanks for reading all of this. As always, feel free to reach out anytime, and hope to see you around the Clojureverse :)</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-08-31-clojurists-together-update-jul-aug-2024.html</id>
    <link href="https://codewithkira.com/2024-08-31-clojurists-together-update-jul-aug-2024.html"/>
    <title>OSS Updates July and August 2024</title>
    <updated>2024-08-31T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>This is a summary of the open source work I've spent my time on throughout July and August, 2024. There was a blog post, some library updates, and lots of community work.</p><h2 id="sponsors">Sponsors</h2><p>This work is made possible by the generous ongoing support of my sponsors. I appreciate all of the support the community has given to my work and would like to give a special thanks to Clojurists Together and Nubank for providing me with lucrative enough grants that I can reduce my client work significantly and afford to spend more time on these projects.</p><p>If you find my work valuable, please share it with others and consider supporting it financially. There are details about how to do that on my <a href='https://github.com/sponsors/kiramclean'>GitHub sponsors page</a>. On to the updates!</p><h2 id="blog&#95;post">Blog post</h2><p>At the beginning of the summer Daniel Slutsky and I were feeling very ambitious and thought we might be able to put together a course for data scientists coming to Clojure from other languages. For many reasons, this hasn't materialized yet, but in service of these plans I wrote a <a href='https://codewithkira.com/2024-07-18-tablecloth-dplyr-pandas-polars.html'>blog post comparing tablecloth</a> to other common data processing tools, like <code>dplyr</code>, <code>pandas</code>, and <code>polars</code>. My goal was to put tablecloth in perspective, illustrating some of the key differences between it and other standard, more popular, data processing tools.</p><h2 id="<code>tcutils</code>"><code>tcutils</code></h2><p>I added a few more helpers to <code>tcutils</code>, like <code>between</code> and <code>duplicate-rows</code>, and also made a <a href='https://scicloj.github.io/tcutils/'>docs website</a> for the project. I also had many interesting conversations with people in the community about how Clojure's data processing tools "feel" to work with, and how we might adopt APIs and conventions that are familiar to data scientists in the interest of making their transition to Clojure's ecosystem as smooth as possible.</p><h2 id="clojure&#95;data&#95;cookbook">Clojure Data Cookbook</h2><p>This month I added a chapter about working with data from databases, starting with SQL, and also continued to work on the end-to-end example for the introductory section. Working with real data is very difficult and interesting, and it's a fun challenge to try to figure out the right balance between getting into the weeds and compromising on the final result. So much of data science is just cleaning up messy data from the world, but surprisingly often you have to make some assumptions about how you're going to use the data in order to make decisions about how to do the cleaning. And there are tons of different ways to "clean" data, but the strategies you use depend on what information you're after.</p><p>In the particular example of the housing dataset I'm working with there are many missing values to handle, and some questionable rows that look like duplicates but aren't <i>exactly</i> duplicates. There are also lots of illogical data points, like house sales from the future or multiple sales for the same property on a given date. Deciding how to handle these cases to build up a "clean" dataset to actually work with is a very interesting exercise in domain modelling and goal setting.</p><h2 id="scicloj&#95;mentoring&#95;program">Scicloj mentoring program</h2><p>This one is really mostly Daniel Slutsky's amazing work, but we collaborated on launching it and it's definitely worth mentioning. We put together a <a href='https://scicloj.github.io/docs/community/groups/open-source-mentoring/'>structured way for people to get involved</a> in contributing to Clojure's open source data science ecosystem, and got an overwhelmingly positive response. Over 25 people reached out to express an interest in contributing their time to Scicloj projects. The structured parts of the program include having some help choosing a meaningful and impactful project to work on, and up to an hour per week of one-on-one time with a mentor to help things progress. Daniel is doing all the heavy lifting coordinating the mentors, but it's been great so far participating as one and meeting some very keen and smart people who are willing to help us move things forward.</p><p>Another big part of this is thinking of the projects to work on. We came up with a list of projects that would deliver high value to the community but remain small enough to tackle by a single developer. We also tried to come up with ones that would require a wide range of skills and interests to try to accommodate as many people as possible. I am super excited to see how things go over the next few months with all of these projects.</p><h2 id="other&#95;community&#95;connections">Other community connections</h2><p>I'm still doing my weekly data-science drop-in streaming with Clojure Camp. I really enjoy connecting with other people who are interested in Clojure for data science, and I often get great suggestions and tips, too.</p><p>I also met with a couple of groups of people who are presenting at the Conj this year to help brainstorm some ideas for how to make the most of the talks. Daniel has amazing vision for the community and organized these calls that I was lucky enough to join. The goal is to connect all of the people who are giving data-related talks to optimize the overall messaging, like minimizing duplication across talks or drawing examples from each other's presentations. I love conference speaking and hope to do more of it in future years when my personal commitments allow for it, but in the meantime it's really amazing getting to connect with such cool people in the community to learn about their talks and brainstorm ideas for making them the best they can be. I'm hoping to attend the conference this year to see some of these great talks in person.</p><h2 id="personal&#95;updates">Personal Updates</h2><p>This has been a really amazing year professionally, having had the opportunity to spend much more time than in the past on open source and public work for the Clojure community. I've been trying to make the most of it and it's been really rewarding. Over the next couple of months, there are some other parts of my life that will be taking precedence, however.</p><p>The main one is my relationship. I'm getting married in a couple of weeks and will be taking almost a month off between getting ready for the wedding, wrapping up all the loose ends afterward, and a nearly 3-week-long honeymoon. I've never taken this long off of work in my life, so I'm both excited and curious to see what it's like. For over a decade now my career has been taking up most of my time and energy. It's been well worth it and I'm really happy with my work now, but I'm also excited to be stepping into a new chapter of life where things can be more balanced.</p><p>Related to this, the other major update I have to share is that I've accepted a full time job with a company called BroadPeak which I will be starting as soon as I'm back from my honeymoon. It's a small fintech company built primarily with Clojure that handles trade data management, commodities transaction surveillance, regulatory compliance, and other things related to the behind-the-scenes of commodities trading. I think it's a perfect fit for my skills and interests, and I'm hoping to have a chance to build some bridges between a really exciting, growing company that uses Clojure for real-world financial data processing and the Clojure open source community. Initial conversations about how the engineering team there feels about open source and community involvement have been really promising, so I'm optimistic that it will work out well for everyone. I'm not sure yet what exactly my open source work will look like once this job starts, but at a minimum I will still be working on the various side projects, like I always was before I tried giving it a go full time.</p><p>No matter how things go, I'll be back in two more months with another update. Thanks for reading. As always, feel free to reach out, and hopefully see some of you at the Conj! :)</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-07-18-tablecloth-dplyr-pandas-polars.html</id>
    <link href="https://codewithkira.com/2024-07-18-tablecloth-dplyr-pandas-polars.html"/>
    <title>Data Manipulation in Clojure Compared to R and Python</title>
    <updated>2024-07-18T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>I spend a lot of time developing and teaching people about Clojure's open source tools for working with data. Almost everybody who wants to use Clojure for this kind of work is coming from another language ecosystem, usually R or Python. Together with Daniel Slutsky, I'm working on formalizing some of the common teachings into a course. Part of that is providing context for people coming from other ecosystems, including "translations" of how to accomplish data science tasks in Clojure.</p><p>As part of this development, I wanted to share an early preview in this blog post. The format is inspired by this great blog post I read a while ago comparing <a href='https://krz.github.io/Comparing-dplyr-with-polars/'>R and Polars</a> side by side (where "R" here refers to <a href='https://www.tidyverse.org'>the tidyverse</a>, an opinionated collection of R libraries for data science, and realistically mostly <a href='https://dplyr.tidyverse.org'><code>dplyr</code></a> specifically). I'm adding Pandas because it's among the most popular dataset manipulation libraries, and of course Clojure, specifically <a href='https://github.com/scicloj/tablecloth'>tablecloth</a>, the primary data manipulation library in our ecosystem.</p><p>I'll use the same dataset as the original blog post, the <a href='https://allisonhorst.github.io/palmerpenguins/articles/intro.html'>Palmer Penguin dataset</a>. For the sake of simplicity, I saved a copy of the dataset as a CSV file and made it available on this website. I will also refer the data as a "dataset" throughout this post because that's what Clojure people call a tabular, column-major data structure, but it's the same thing that is variously referred to as a dataframe, data table, or just "data" in other languages. I'm also assuming you know how to install the packages required in the given ecosystems, but any necessary imports or requirements are included in the code snippets the first time they appear. Versions of all languages and libraries used in this post are listed at the end. Here we go!</p><h2 id="reading&#95;data">Reading data</h2><p>Reading data is straightforward in every language, but as a bonus we want to be able to indicate on the fly which values should be interpreted as "missing", whatever that means in the given libraries. In this dataset, the string <code>&quot;NA&quot;</code> means "missing", so we want to tell the dataset constructor this as soon as possible. Here's the comparison of how to accomplish that in various languages:</p><h3 id="tablecloth">Tablecloth</h3><pre><code class="lang-clojure">&#40;require '&#91;tablecloth.api :as tc&#93;&#41;

&#40;def ds 
  &#40;tc/dataset &quot;https://codewithkira.com/assets/penguins.csv&quot;&#41;&#41;
</code></pre><p>Note that tablecloth interprets the string "NA" as missing (<code>nil</code>, in Clojure) by default.</p><h3 id="r">R</h3><p>In reality, in R you would get the dataset from the R <a href='https://allisonhorst.github.io/palmerpenguins/articles/intro.html'>package that contains the dataset</a>. This is a fairly common practice in R. In order to compare apples to apples, though, here I'll show how to initialize the dataset from a remote CSV file, using the <a href='https://readr.tidyverse.org/reference/read_delim.html'><code>readr</code> package's <code>read&#95;csv</code></a>, which is part of the tidyverse:</p><pre><code class="lang-r">library&#40;tidyverse&#41;

ds &lt;- read&#95;csv&#40;&quot;https://codewithkira.com/assets/penguins.csv&quot;,
               na = &quot;NA&quot;&#41;
</code></pre><h3 id="pandas">Pandas</h3><pre><code class="lang-python">import pandas as pd

ds = pd.read&#95;csv&#40;&quot;https://codewithkira.com/assets/penguins.csv&quot;&#41;
</code></pre><p>Note that pandas has a <a href='https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html'>fairly long list</a> of values it considers <code>NaN</code> already, so we don't need to specify what missing values look like in our case, since <code>&quot;NA&quot;</code> is already in that list.</p><h3 id="polars">Polars</h3><pre><code class="lang-python">import polars as pl

ds = pl.read&#95;csv&#40;&quot;https://codewithkira.com/assets/penguins.csv&quot;,
                 null&#95;values=&quot;NA&quot;&#41;
</code></pre><h2 id="basic&#95;commands&#95;to&#95;explore&#95;the&#95;dataset">Basic commands to explore the dataset</h2><p>The first thing people usually want to do with their dataset is see it and poke around a bit. Below is a comparison of how to accomplish basic data exploration tasks using each library.</p><table><thead><tr><th>Operation</th><th>tablecloth</th><th>dplyr</th></tr></thead><tbody><tr><td>see first 10 rows</td><td><code>&#40;tc/head ds 10&#41;</code></td><td><code>head&#40;ds, 10&#41;</code></td></tr><tr><td>see all column names</td><td><code>&#40;tc/column-names ds&#41;</code></td><td><code>colnames&#40;ds&#41;</code></td></tr><tr><td>select column</td><td><code>&#40;tc/select-columns ds &quot;year&quot;&#41;</code></td><td><code>select&#40;ds, year&#41;</code></td></tr><tr><td>select multiple columns</td><td><code>&#40;tc/select-columns ds &#91;&quot;year&quot; &quot;sex&quot;&#93;&#41;</code></td><td><code>select&#40;ds, year, sex&#41;</code></td></tr><tr><td>select rows</td><td><code>&#40;tc/select-rows ds #&#40;&gt; &#40;% &quot;year&quot;&#41; 2008&#41;&#41;</code></td><td><code>filter&#40;ds, year &gt; 2008&#41;</code></td></tr><tr><td>sort column</td><td><code>&#40;tc/order-by ds &quot;year&quot;&#41;</code></td><td><code>arrange&#40;ds, year&#41;</code></td></tr></tbody></table><p><br></p><table><thead><tr><th>Operation</th><th>pandas</th><th>polars</th></tr></thead><tbody><tr><td>see first <code>n</code> rows</td><td><code>ds.head&#40;10&#41;</code></td><td><code>ds.head&#40;10&#41;</code></td></tr><tr><td>see all column names</td><td><code>ds.columns</code></td><td><code>ds.columns</code></td></tr><tr><td>select column</td><td><code>ds&#91;&#91;&quot;year&quot;&#93;&#93;</code></td><td><code>ds.select&#40;pl.col&#40;&quot;year&quot;&#41;&#41;</code></td></tr><tr><td>select multiple columns</td><td><code>ds&#91;&#91;&quot;year&quot;, &quot;sex&quot;&#93;&#93;</code></td><td><code>ds.select&#40;pl.col&#40;&quot;year&quot;, &quot;sex&quot;&#41;&#41;</code></td></tr><tr><td>select rows</td><td><code>ds&#91;ds&#91;&quot;year&quot;&#93; &gt; 2008&#93;</code></td><td><code>ds.filter&#40;pl.col&#40;&quot;year&quot;&#41; &gt; 2008&#41;</code></td></tr><tr><td>sort column</td><td><code>ds.sort&#95;values&#40;&quot;year&quot;&#41;</code></td><td><code>ds.sort&#40;&quot;year&quot;&#41;</code></td></tr></tbody></table><p>Note there are some differences in how different libraries sort missing values, for example in tablecloth and polars they are placed at the beginning (so they're at the top when a column is sorted in ascending order and last when descending), but dplyr and pandas place them last (regardless of whether ascending or descending order is specified).</p><p>As you can see, these commands are all pretty similar, with the exception of selecting rows in tablecloth. This is a short-hand syntax for writing an anonymous function in Clojure, which is how rows are selected. Being a functional language, functions in Clojure are "first-class", which basically just means they are passed around as arguments willy-nilly, all over the place, all the time. In this case, the third argument to tablecloth's <code>select-rows</code> function is a predicate (a function that returns a boolean) that takes as its argument a dataset row as a map of column names to values. Don't worry, though, tablecloth doesn't process your entire dataset row-wise. Under the hood datasets are highly optimized to perform column-wise operations as fast as possible.</p><p>Here's an example of what it looks like to string a couple of these basic dataset exploration operations together, for example in this case to get the <code>bill&#95;length&#95;mm</code> of all penguins with <code>body&#95;mass&#95;g</code> below 3800:</p><h3 id="tablecloth">Tablecloth</h3><pre><code class="lang-clojure">&#40;-&gt; ds
    &#40;tc/select-rows #&#40;and &#40;% &quot;body&#95;mass&#95;g&quot;&#41;
                          &#40;&gt; &#40;% &quot;body&#95;mass&#95;g&quot;&#41; 3800&#41;&#41;&#41;
    &#40;tc/select-columns &quot;bill&#95;length&#95;mm&quot;&#41;&#41;
</code></pre><p>Note that in tablecloth we have to explicitly omit rows where the value we're filtering by is missing, unlike in other libraries. This is because tablecloth actually uses <code>nil</code> (as opposed to a library-specific construct) to indicate a missing value , and in Clojure <code>nil</code> is not treated as comparable to numbers. If we were to try to compare <code>nil</code> to a number, we would get an exception telling us that we're trying to compare incomparable types. Clojure is fundamentally dynamically typed in that it only does type checking at runtime and bindings can refer to values of any type, but it is also strongly typed, as we see here, in the sense that it explicitly avoids implicit type coercion. For example deciding whether 0 is greater or larger than <code>nil</code> requires some assumptions, and these are intentionally not baked into the core of Clojure or into tablecloth as a library as is the case in some other languages and libraries.</p><p>This example also introduces Clojure's "thread-first" macro. The <code>-&gt;</code> arrow is like R's <code>|&gt;</code> operator or the unix pipe, effectively passing the output of each function in the chain as input to the next. It comes in very handy for data processing code like this.</p><p>Here is the equivalent operation in the other libraries:</p><h3 id="dplyr">dplyr</h3><pre><code class="lang-r">ds |&gt;
    filter&#40;body&#95;mass&#95;g &lt; 3800&#41; |&gt;
    select&#40;bill&#95;length&#95;mm&#41;
</code></pre><h3 id="pandas">Pandas</h3><pre><code class="lang-python">ds&#91;ds&#91;&quot;body&#95;mass&#95;g&quot;&#93; &lt; 3800&#93;&#91;&quot;bill&#95;length&#95;mm&quot;&#93;
</code></pre><h3 id="polars">Polars</h3><pre><code class="lang-python">ds.filter&#40;pl.col&#40;&quot;body&#95;mass&#95;g&quot;&#41; &lt; 3800&#41;.select&#40;pl.col&#40;&quot;bill&#95;length&#95;mm&quot;&#41;&#41;
</code></pre><h2 id="more&#95;advanced&#95;filtering&#95;and&#95;selecting">More advanced filtering and selecting</h2><p>Here is what some more complicated data wrangling looks like across the libraries.</p><h3 id="select&#95;all&#95;columns&#95;except&#95;for&#95;one">Select all columns except for one</h3><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>&#40;tc/select-columns ds &#40;complement #{&quot;year&quot;}&#41;&#41;</code></td></tr><tr><td>dplyr</td><td><code>select&#40;ds, -year&#41;</code></td></tr><tr><td>pandas</td><td><code>ds.drop&#40;columns=&#91;&quot;year&quot;&#93;&#41;</code></td></tr><tr><td>polars</td><td><code>ds.select&#40;pl.exclude&#40;&quot;year&quot;&#41;&#41;</code></td></tr></tbody></table><p>Another property of functional languages in general, and especially Clojure, is that they really take advantage of the fact that a lot of things are functions that you might not be used to treating like functions. They also leverage function composition to simply combine multiple functions into a single operation.</p><p>For example a set (indicated with the <code>#{}</code> syntax in Clojure) is a special function that returns a boolean indicating whether the given argument is a member of the set or not. And <a href='https://clojuredocs.org/clojure.core/complement'><code>complement</code></a> is a function in <code>clojure.core</code> that effectively inverts the function given to it, so combined <code>&#40;complement #{&quot;year&quot;}&#41;</code> means "every value that is <i>not</i> in the set <code>#{&quot;year&quot;}</code>, which we can then use as our predicate column selector function to filter out certain columns.</p><h3 id="select&#95;all&#95;columns&#95;that&#95;start&#95;with&#95;a&#95;given&#95;string">Select all columns that start with a given string</h3><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>&#40;tc/select-columns ds #&#40;str/starts-with? % &quot;bill&quot;&#41;&#41;</code></td></tr><tr><td>dplyr</td><td><code>select&#40;ds, starts&#95;with&#40;&quot;bill&quot;&#41;&#41;</code></td></tr><tr><td>pandas</td><td><code>ds.filter&#40;regex=&quot;&#94;bill&quot;&#41;</code></td></tr><tr><td>polars</td><td><pre style="width:max-content"><code>import polars.selectors as cs</code><br><code>ds.select(cs.starts_with("bill"))</code></pre></td></tr></tbody></table><h3 id="select&#95;only&#95;numeric&#95;columns">Select only numeric columns</h3><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>&#40;tc/select-columns ds :type/numerical&#41;</code></td></tr><tr><td>dplyr</td><td><code>select&#40;ds, where&#40;is.numeric&#41;&#41;</code></td></tr><tr><td>pandas</td><td><code>ds.select&#95;dtypes&#40;include='number'&#41;</code></td></tr><tr><td>polars</td><td><code>ds.select&#40;cs.numeric&#40;&#41;&#41;</code></td></tr></tbody></table><p>The symbol <code>:type/numerical</code> in Clojure here is a magic keyword that tablecloth knows about and can accept as a column selector. This list of magic keywords that tablecloth knows about is not (yet) documented anywhere, but it is <a href='https://github.com/scicloj/tablecloth/blob/b0faadcd202d4355767f7e212a4d86e099eb5f96/src/tablecloth/api/utils.clj#L59'>available in the source code</a>.</p><h3 id="filter&#95;rows&#95;for&#95;range&#95;of&#95;values">Filter rows for range of values</h3><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>&#40;tc/select-rows ds #&#40;&lt; 3500 &#40;% &quot;body&#95;mass&#95;g&quot; 0&#41; 4000&#41;&#41;</code></td></tr><tr><td>dplyr</td><td><code>filter&#40;ds, between&#40;body&#95;mass&#95;g, 3500, 4000&#41;&#41;</code></td></tr><tr><td>pandas</td><td><code>ds&#91;ds&#91;&quot;body&#95;mass&#95;g&quot;&#93;.between&#40;3500, 4000&#41;&#93;</code></td></tr><tr><td>polars</td><td><code>ds.filter&#40;pl.col&#40;&quot;body&#95;mass&#95;g&quot;&#41;.is&#95;between&#40;3500, 4000&#41;&#41;</code></td></tr></tbody></table><p>Note here we handle the missing values in the <code>body&#95;mass&#95;g</code> column differently than above, by specifying a default value for the map lookup. We're explicitly telling tablecloth to treat missing values as <code>0</code> in this case, which can then be compared to other numbers. This is probably the better way to handle this case, but the method above works, too, plus it gave me the opportunity to soapbox about Clojure types for a moment.</p><h3 id="reshaping&#95;the&#95;dataset">Reshaping the dataset</h3><h4 id="tablecloth">Tablecloth</h4><pre><code class="lang-clojure">&#40;tc/pivot-&gt;longer ds 
                  &#91;&quot;bill&#95;length&#95;mm&quot; &quot;bill&#95;depth&#95;mm&quot;
                   &quot;flipper&#95;length&#95;mm&quot; &quot;body&#95;mass&#95;g&quot;&#93;
                  {:target-columns &quot;measurement&quot; :value-column-name &quot;value&quot;}&#41;
</code></pre><h4 id="dplyr">dplyr</h4><pre><code class="lang-r">ds |&gt;
    pivot&#95;longer&#40;cols = c&#40;bill&#95;length&#95;mm, bill&#95;depth&#95;mm,
                          flipper&#95;length&#95;mm, body&#95;mass&#95;g&#41;,
                 names&#95;to = &quot;measurement&quot;,
                 values&#95;to = &quot;value&quot;&#41;
</code></pre><h4 id="pandas">Pandas</h4><pre><code class="lang-python">pd.melt&#40;
    ds, 
    id&#95;vars=ds.columns.drop&#40;&#91;&quot;bill&#95;length&#95;mm&quot;, &quot;bill&#95;depth&#95;mm&quot;, 
                             &quot;flipper&#95;length&#95;mm&quot;, &quot;body&#95;mass&#95;g&quot;&#93;&#41;, 
    var&#95;name=&quot;measurement&quot;,
    value&#95;name=&quot;value&quot;
&#41;
</code></pre><h4 id="polars">Polars</h4><pre><code class="lang-python">ds.unpivot&#40;
     index=set&#40;ds.columns&#41; - set&#40;&#91;&quot;bill&#95;length&#95;mm&quot;,
                                  &quot;bill&#95;depth&#95;mm&quot;,
                                  &quot;flipper&#95;length&#95;mm&quot;,
                                  &quot;body&#95;mass&#95;g&quot;&#93;&#41;,
     variable&#95;name=&quot;measurement&quot;,
     value&#95;name=&quot;value&quot;&#41;
</code></pre><h2 id="creating&#95;and&#95;renaming&#95;columns">Creating and renaming columns</h2><h3 id="adding&#95;columns&#95;based&#95;on&#95;some&#95;other&#95;existing&#95;columns">Adding columns based on some other existing columns</h3><p>There are many reasons you might want to add columns, and often new columns are combinations of other ones. Here's how you'd generate a new column based on the values in some other columns in each library:</p><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><pre style="width:max-content"><code>(require '[tablecloth.column.api :as tcc])<br>(tc/add-columns ds {"ratio" (tcc// (ds "bill&#95;length&#95;mm")<br>                                   (ds "flipper&#95;length&#95;mm"))})</code></pre></td></tr><tr><td>dplyr</td><td><code>mutate&#40;ds, ratio = bill&#95;length&#95;mm / flipper&#95;length&#95;mm&#41;</code></td></tr><tr><td>pandas</td><td><code>ds&#91;&quot;ratio&quot;&#93; = ds&#91;&quot;bill&#95;length&#95;mm&quot;&#93; / ds&#91;&quot;flipper&#95;length&#95;mm&quot;&#93;</code></td></tr><tr><td>polars</td><td><pre style="width:max-content"><code>ds.with&#95;columns(<br>    (pl.col("bill&#95;length&#95;mm") /<br>     pl.col("flipper&#95;length&#95;mm")).alias("ratio")<br>)</code></pre></td></tr></tbody></table><p>Note that this is where the wheels start to come off if you're not working in a functional way with immutable data structures. Clojure data structures (including tablecloth datasets) are immutable, which is not the case Pandas. The Pandas code above mutates the dataset in place, so as soon as you do any mutating operations like these, you now have to keep mental track of the state of your dataset, which can quickly lead to high cognitive overhead and lots of incidental complexity.</p><h3 id="renaming&#95;columns">Renaming columns</h3><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>&#40;tc/rename-columns ds {&quot;bill&#95;length&#95;mm&quot; &quot;bill&#95;length&quot;}&#41;</code></td></tr><tr><td>dplyr</td><td><code>rename&#40;ds, bill&#95;length = bill&#95;length&#95;mm&#41;</code></td></tr><tr><td>pandas</td><td><code>ds.rename&#40;columns={&quot;bill&#95;length&#95;mm&quot;: &quot;bill&#95;length&quot;}&#41;</code></td></tr><tr><td>polars</td><td><code>ds.rename&#40;{&quot;bill&#95;length&#95;mm&quot;: &quot;bill&#95;length&quot;}&#41;</code></td></tr></tbody></table><p>Again beware, the Pandas implementation shown here mutates the dataset in place. Also manually specifying every column name transformation you want to do is one way to accomplish the task, but sometimes that can be tedious if you want to apply the same transformation to every column name, which is fairly common.</p><h3 id="transforming&#95;column&#95;names">Transforming column names</h3><p>Here's how you would upper case all column names:</p><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>&#40;tc/rename-columns ds :all str/upper-case&#41;</code></td></tr><tr><td>dplyr</td><td><code>rename&#95;with&#40;ds, toupper&#41;</code></td></tr><tr><td>pandas</td><td><code>ds.columns = ds.columns.str.upper&#40;&#41;</code></td></tr><tr><td>polars</td><td><code>ds.select&#40;pl.all&#40;&#41;.name.to&#95;uppercase&#40;&#41;&#41;</code></td></tr></tbody></table><p>Like the other libraries, tablecloth's <code>rename-columns</code> accepts both types of arguments &ndash; a simple mapping of old -> new column names, or any column selector and any transformation function. For example, removing the units from each column name would look like this in each language:</p><table><thead><tr><th>Library</th><th>Code</th></tr></thead><tbody><tr><td>tablecloth</td><td><code>(tc/rename-columns ds #".+&#95;(mm&#124;g)" #(str/replace % #"(.+)&#95;(mm&#124;g)" "$1"))</code></td></tr><tr><td>dplyr</td><td><code>rename&#95;with(penguins, ~ str&#95;replace(.x, "&#94;(.+)&#95;(mm&#124;g)$", "&#92;1"))</code></td></tr><tr><td>pandas</td><td><pre style="width:max-content"><code>import re<br>ds.rename(columns=lambda x: re.sub(r"(.+)_(mm&#124;g)$", r"\1", x))</code></pre></td></tr><tr><td>polars</td><td><pre style="width:max-content"><code>ds = ds.rename({<br>    col: col.replace("&#95;mm", "").replace("&#95;g", "")<br>    for col in ds.columns<br>})</code></pre></td></tr></tbody></table><h2 id="grouping&#95;and&#95;aggregating">Grouping and aggregating</h2><p>Grouping behaves <a href='https://scicloj.github.io/tablecloth/index.html#group-by'>somewhat unconventionally in tablecloth</a>. Datasets can be grouped by a single column name or a sequence of column names like in other libraries, but grouping can also be done using any arbitrary function. Grouping in tablecloth also returns a new dataset, similar to dplyr, rather than an abstract intermediate object (as in pandas and polars). Grouped datasets have three columns, (name of the group, group id, and a column containing a new dataset of the grouped data). Once a dataset is grouped, the group values can be aggregated in a variety of ways. Here are a few examples, with comparisons between libraries:</p><h3 id="summarizing&#95;counts">Summarizing counts</h3><p>To get the count of each penguin by species:</p><h4 id="tablecloth">Tablecloth</h4><pre><code class="lang-clojure">&#40;-&gt; ds
    &#40;tc/group-by &#91;&quot;species&quot;&#93;&#41;
    &#40;tc/aggregate {&quot;count&quot; tc/row-count}&#41;&#41;
</code></pre><h4 id="dplyr">dplyr</h4><pre><code class="lang-r">ds |&gt;
    group&#95;by&#40;species&#41; |&gt;
    summarise&#40;count = n&#40;&#41;&#41;
</code></pre><h4 id="pandas">Pandas</h4><pre><code class="lang-python">ds.groupby&#40;&quot;species&quot;&#41;.agg&#40;count=&#40;&quot;species&quot;, &quot;count&quot;&#41;&#41;
</code></pre><h4 id="polars">Polars</h4><pre><code class="lang-python">ds.group&#95;by&#40;&quot;species&quot;&#41;.agg&#40;pl.count&#40;&#41;.alias&#40;&quot;count&quot;&#41;&#41;
</code></pre><h3 id="find&#95;the&#95;penguin&#95;with&#95;the&#95;lowest&#95;body&#95;mass&#95;by&#95;species">Find the penguin with the lowest body mass by species</h3><h4 id="tablecloth">Tablecloth</h4><pre><code class="lang-clojure">&#40;-&gt; ds
    &#40;tc/group-by &#91;&quot;species&quot;&#93;&#41;
    &#40;tc/aggregate {&quot;lowest&#95;body&#95;mass&#95;g&quot; #&#40;-&gt;&gt; &#40;% &quot;body&#95;mass&#95;g&quot;&#41;
                                              tcc/drop-missing
                                              &#40;apply tcc/min&#41;&#41;}&#41;&#41;
</code></pre><h4 id="dplyr">dplyr</h4><pre><code class="lang-r">ds |&gt;
    group&#95;by&#40;species&#41; |&gt;
    summarize&#40;lowest&#95;body&#95;mass&#95;g = min&#40;body&#95;mass&#95;g, na.rm = TRUE&#41;&#41;
</code></pre><h4 id="pandas">Pandas</h4><pre><code class="lang-python">ds.groupby&#40;&quot;species&quot;&#41;.agg&#40;
    lowest&#95;body&#95;mass&#95;g=&#40;&quot;body&#95;mass&#95;g&quot;, lambda x: x.min&#40;skipna=True&#41;&#41;
&#41;.reset&#95;index&#40;&#41;
</code></pre><h4 id="polars">Polars</h4><pre><code class="lang-python">ds.group&#95;by&#40;&quot;species&quot;&#41;.agg&#40;
    pl.col&#40;&quot;body&#95;mass&#95;g&quot;&#41;.min&#40;&#41;.alias&#40;&quot;lowest&#95;body&#95;mass&#95;g&quot;&#41;
&#41;
</code></pre><h2 id="conclusions">Conclusions</h2><p>As you can see, all of these libraries are perfectly suitable for accomplishing common data manipulation tasks. Choosing a language and library can impact code readability, maintainability, and performance, though, so understanding the differences between available toolkits can help us make better choices.</p><p>Clojure's tablecloth emphasizes functional programming concepts and immutability, which can lead to more predictable and re-usable code, at the cost of adopting a potentially new paradigm. Hopefully this comparison serves not only as a translation guide, but an an intro to the different philosophies underpinning these common data science tools.</p><p>Thanks for reading :)</p><h2 id="versions">Versions</h2><p>The code in this post works with the following language and library versions:</p><table><thead><tr><th>Tool</th><th>Version</th></tr></thead><tbody><tr><td>MacOS</td><td>Sonoma 14.5</td></tr><tr><td>JVM</td><td><code>21.0.2</code></td></tr><tr><td>Clojure</td><td><code>1.11.1</code></td></tr><tr><td>Tablecloth</td><td><code>7.021</code></td></tr><tr><td>R</td><td><code>4.4.1</code></td></tr><tr><td>Tidyverse</td><td><code>2.0.0</code></td></tr><tr><td>Python</td><td><code>3.12.3</code></td></tr><tr><td>Pandas</td><td><code>2.1.4</code></td></tr><tr><td>Polars</td><td><code>1.1.0</code></td></tr></tbody></table>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-06-30-clojurists-together-update-may-jun-2024.html</id>
    <link href="https://codewithkira.com/2024-06-30-clojurists-together-update-may-jun-2024.html"/>
    <title>OSS Updates May and June 2024</title>
    <updated>2024-06-30T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>This is a summary of the open source work I've spent my time on throughout May and June, 2024. There were lots of small bug fixes and reports, driven by work on the Clojure Data Cookbook. This work was also the impetus for my initial release of <a href='https://github.com/scicloj/tcutils'><code>tcutils</code></a>, a library of utility functions for working with tablecloth datasets. I also had the wonderful opportunity to attend PyData London in June and found it really insightful and inspiring. Read on for more details.</p><h2 id="sponsors">Sponsors</h2><p>This work is made possible by the generous ongoing support of my sponsors. I appreciate all of the support the community has given to my work and would like to give a special thanks to Clojurists Together and Nubank for providing me with lucrative enough grants that I can reduce my client work significantly and afford to spend more time on these projects.</p><p>If you find my work valuable, please share it with others and consider supporting it financially. There are details about how to do that on my <a href='https://github.com/sponsors/kiramclean'>GitHub sponsors page</a>. On to the updates!</p><h2 id="ecosystem&#95;issue&#95;reports&#95;and&#95;bug&#95;fixes">Ecosystem issue reports and bug fixes</h2><p>Working on the cookbook these last couple of months turned up a few small issues in ecosystem libraries. The other developers of Clojure's data science tools are such a pleasure to work with, it's so rare and nice to have a distributed team of people capable of getting cool things built asynchronously. Here are some details of a few particular issues that came up:</p><ul><li>Small problem loading .xls/.xlsx files as datasets if they had a number as a column name: <a href='https://clojurians.zulipchat.com/#narrow/stream/236259-tech.2Eml.2Edataset.2Edev/topic/xlsx.20column.20parsing/near/437313810'>discussed here</a>, <a href='https://github.com/techascent/tech.ml.dataset/issues/408'>reported here</a>, and graciously <a href='https://github.com/techascent/tech.ml.dataset/commit/24c0e646f289210aa95c1ac9998cb2ddd5c9f836'>fixed by Chris Nuernberger</a>.</li><li>Unexpected behaviour when comparing certain numeric types in <code>dtype-next</code>: <a href='https://clojurians.zulipchat.com/#narrow/stream/236259-tech.2Eml.2Edataset.2Edev/topic/numeric.20datatypes/near/438617694%5D(https://clojurians.zulipchat.com/%23narrow/stream/236259-tech.2Eml.2Edataset.2Edev/topic/numeric.20datatypes/near/438617694'>discussed here</a>, <a href='https://github.com/cnuernber/dtype-next/issues/99'>reported here</a>, and again <a href='https://github.com/cnuernber/dtype-next/commit/563fe9c13797feb206391cd951655942e3e6cf0f'>fixed by Chris</a>. This one sadly had some unintended consequences that <a href='https://github.com/cnuernber/dtype-next/issues/103'>generateme found and reported here</a>.</li><li><a href='https://github.com/scicloj/clay/blob/b299d060c3edbce789a55fee3efedce42fbd2ab4/CHANGELOG.md'>Many improvements to Clay</a> by Daniel Slutsky, especially a couple of ones that make the quarto publications it produces much nicer: <a href='https://github.com/scicloj/clay/pull/102'>fixing too-wide tables in quarto pages</a> and <a href='https://clojurians.zulipchat.com/#narrow/stream/321125-noj-dev/topic/kindly.20options/near/440663980'>supporting limiting the number of table rows that get displayed</a>.</li><li>Some good discussions about how best to incorporate the myriad of dependencies required to use Java machine learning libraries in Clojure libs, including sorting out what to do about <a href='https://github.com/scicloj/scicloj.ml.tribuo/issues/1'>transitive dependencies in our tribuo wrapper</a>, led by Carsten Behring.</li></ul><h2 id="initial&#95;release&#95;of&#95;tcutils">Initial release of tcutils</h2><p>In my explorations of other languages' tools for working data I often come across nice utility functions that are super simple but have a big impact on the ergonomics of using the tools. I wanted to start bringing some of these convenience utilities to Clojure, so for now I'm putting them in <a href='https://github.com/scicloj/tcutils'><code>tcutils</code></a>. So far only a handful of helpers are implemented (<code>lag</code>, <code>lead</code>, <code>cumsum</code>, and <code>clean-column-names</code>). The goal is to eventually fill out more utilities that save people from having to dig into the documentation of half a dozen different libraries to figure out how to implement things like these. The goal is not to achieve feature parity or to exactly copy similar libraries, like pandas or dplyr, but rather to take inspiration from them and make our tools easier to use for people who are used to these conveniences.</p><h2 id="progress&#95;on&#95;clojure&#95;data&#95;cookbook">Progress on Clojure Data Cookbook</h2><p>I spent a lot of time on the Clojure Data Cookbook over these last two months. Notable progress includes:</p><ul><li>The introductory chapters bear some resemblance now to the final form they'll take.</li><li>The overall structure of the book is much more clear now.</li><li>I started the example analysis that will serve as the high-level introductory section of the book.</li><li>The publishing and deployment process is finally working.</li></ul><p>It's still very much in progress, but in the interest of transparency the work-in-progress version is <a href='https://github.com/scicloj/clojure-data-cookbook'>available online now</a>. It will continue to evolve and change as I fill out more and more of the chapters, but there's enough of it available now to hopefully give a sense of the style and tone I'm going for. I also finally have the publishing workflow set up and it's generating a nice-looking Quarto book, thanks to all of Daniel Slutsky's amazing work on Clay and Quarto integration recently.</p><h2 id="progress&#95;on&#95;high-level&#95;goals">Progress on high-level goals</h2><p>The high-level goal of my work in general remains to steward Clojure's data science ecosystem to a state of maturity and flourishing so that data practitioners can use it to get real work done. Toward this end, I set up a <a href='https://github.com/users/kiramclean/projects/4'>project board</a> to track progress toward what I see as the main components of this project. </p><p>Over the last couple of months, beginning with a prototype demoed at my <a href='https://www.youtube.com/watch?v=eUFf3-og_-Y'>London Clojurians talk in April</a>, Daniel Slutsky has made tremendous progress on our goal of implementing a grammar of graphics in Clojure in the new <a href='https://github.com/scicloj/hanamicloth'>hanamicloth library</a>. The near-term goal is to stabilize the API of this library enough that it can be used to provide a user-friendly way to accomplish all of the simple data visualization tasks that are currently possible with our other tools. The long term goal is to take the lessons we learn from this library and build a JVM-only grammar of graphics library for doing data visualization "right" in Clojure.</p><p>The development and surrounding discussions of hanamicloth have also made me realize it would be useful to write an overview of the current state of dataviz options for Clojure and why we're working on building something new. That's on my list for the coming months, but lower priority than actual development work.</p><h2 id="impressions&#95;from&#95;pydata&#95;london">Impressions from PyData London</h2><p>I got to attend PyData London this year thanks to a client of mine who was sponsoring the conference. I learned a lot and found the talks very interesting. My overall impression is that data science is maturing as a discipline, with more polished methods and robust theory backing up different approaches to data-related problems. With this maturation, though, comes higher expectations for production-ready, professional quality results. Most of the talks focused on high-level concerns like observability, scalability, and long-term stewardship of large open-source projects.</p><p>There are a lot of reasons why Python is just not ideal for building highly available, high-performance systems, and I really believe this is a good time to be building alternative tools for data science. Python is obviously entrenched as the current default language for working with data, but it is difficult and slow to write code that can take full advantage of modern hardware (because of the infamous global interpreter lock, reference counting, slow I/O, among other reasons). And to be fair, the Python community knows this. It's why virtually all of the libraries that do the heavy lifting for data science in Python are actually implemented in C (numpy,  pandas) or Rust (Polars, Pydantic), or are wrappers around C++ (PyTorch, TensorFlow, matplotlib) or Java (PySpark, Pydoop, confluent-kafka) libraries. </p><p>I think this provides a lot of insights into what data practitioners want. It's clear that users <i>want</i> approachable, simple, human-readable interfaces for all of these tools, and that any new tool needs to interoperate with the rest of the ones currently in use. People are also <a href='https://news.ycombinator.com/item?id=40815097'>tired of churn</a> and are craving stability. I think Clojure has a lot to offer in all of these areas and is well placed to become more widely adopted for data science.</p><h2 id="ongoing&#95;work">Ongoing work</h2><p>My focus over the next two months will remain on the cookbook. My main goal is to finish the introductory chapter with the housing price analysis and to continue putting together the data import section with instructions and examples for all file formats that can reasonably be supported easily at this time.</p><p>I'll continue to support and contribute to all of the ecosystem libraries I come across in my writings and analysis work in hopes of smoothing out all the rough edges I find.</p><p>Thanks for reading. I always love hearing from people who are interested in any of the things I'm working on. If that's you, don't hesitate to be in touch :)</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-04-30-clojurists-together-update-mar-apr-2024.html</id>
    <link href="https://codewithkira.com/2024-04-30-clojurists-together-update-mar-apr-2024.html"/>
    <title>OSS Updates March and April 2024</title>
    <updated>2024-04-30T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>This is a summary of the open source work I've spent my time on throughout March and April, 2024. Overall it was a really insightful couple of months for me, with lots of productive discussions and meetings happening among key contributors to Clojure's data science ecosystem and great progress toward some of our most ambitious goals.</p><h2 id="sponsors">Sponsors</h2><p>This work is made possible by the generous ongoing support of my sponsors. I appreciate all of the support the community has given to my work and would like to give a special thanks to Clojurists Together and Nubank for providing me with lucrative enough grants that I can reduce my client work significantly and afford to spend more time on these projects.</p><p>If you find my work valuable, please share it with others and consider supporting it financially. There are details about how to do that on my <a href='https://github.com/sponsors/kiramclean/'>GitHub sponsors page</a>. On to the updates!</p><h2 id="grammar&#95;of&#95;graphics&#95;in&#95;clojure">Grammar of graphics in Clojure</h2><p>With help from Daniel Slutsky and others in the community, I started some concrete work on implementing a grammar of graphics in Clojure. I'm convinced this is the correct long-term solution for dataviz in Clojure, but it is a big project that will take time, including a lot of <a href='https://www.youtube.com/watch?v=f84n5oFoZBc'>hammock time</a>. It's still useful to play around with proofs of concept whilst thinking through problems, though, and in the interest of transparency I'm making all of <a href='https://github.com/kiramclean/ggclj'>those experiments public</a>.</p><p>The discussions around this development are all also happening in public. There were two visual tools meetups focused on this over the last two months (<a href='https://www.youtube.com/watch?v=MxjzaOtcdcY'>link 1</a>, <a href='https://www.youtube.com/watch?v=d3iRGmbJmes'>link 2</a>). And at the London Clojurians talk I just gave today I demonstrated an example of one proposed implementation of a <a href='https://github.com/kiramclean/workshops/blob/main/london_clojurians_april_2024/src/utils/hana.clj'>grammar-of-graphics-like API</a> on top of hanami implemented by Daniel.</p><p>There are more meetups planned for the coming months and work in this area for the foreseeable future will look like researching and understanding the fundamentals of the grammar of graphics in order to design a simple implementation in Clojure.</p><h2 id="clojure's&#95;ml&#95;and&#95;statistics&#95;tools">Clojure's ML and statistics tools</h2><p>I spent a lot of time these last couple of months documenting and testing out Clojure's current ML tools, leading to many great conversations and one <a href='https://codewithkira.com/2024-04-04-state-of-clojure-ml.html'>blog post</a> that generated many more interesting discussions. The takeaway is that the tools themselves in this area are all quite mature and stable, but there are still ongoing discussions around how to best accommodate the different ways that people want to work with them. The overall goal in this area of my work is to stabilize the solutions so we can start advocating for specific ways of using them.</p><p>Below are some key takeaways from my research into all this stuff. Note none of these are my decisions to make alone, but represent my current opinions and what I will be advocating for within the community:</p><ul><li>Smile will be slowly sunsetted from the ecosystem. The switch to GPL licensing was made in bad faith and many of the common models don't work on Apple chips. Given the abundance of suitable alternatives, the easiest option is to move away from depending on it.</li><li>A greater distinction between statistical modelling and machine learning workflows will be helpful. Right now there are many uses of the various models that are available in Clojure, and the wrappers and tools surrounding them are usually designed with a specific type of user in mind. For example machine learning people almost always have separate training and testing datasets, whereas statisticians "train" their models on an entire dataset. The highest-level APIs for these different usages (among others) look quite different, and we would benefit from having APIs that are ergonomic and familiar to our target users of various backgrounds.</li><li>We should agree on standards for accomplishing certain very common and basic tasks and propose a recommended usage for users. For example, there are almost a dozen ways to do linear regression in Clojure and it's not obvious which is "the best" way to someone not deeply familiar with the ecosystem.</li><li>Everything should work with tablecloth datasets and expect them as inputs. This is mostly the case already, but there is still some progress to be made.</li></ul><h2 id="foundations&#95;of&#95;clojure's&#95;data&#95;science&#95;stack">Foundations of Clojure's data science stack</h2><p>I continue to work on guides and tutorials for the parts of Clojure's data science stack that I feel are ready for prime time, mainly tablecloth and all of the amazing underlying libraries it leverages. Every once in a while this turns up surprises, for example this month I was surprised at how column header processing is handled for nippy files specifically. I also <a href='https://github.com/scicloj/tablecloth/pull/143'>fixed one bug</a> in tablecloth itself, which I discovered in the process of writing a tutorial earlier in March. I have a pile of in-progress guides focusing on some more in-depth topics from developing the London Clojurians talk that I'm going to tidy up and publish in the coming months.</p><p>The overarching goal in this area is to create a unified data science stack with libraries for processing, modelling, and visualization that all interoperate seamlessly and work with tablecloth datasets, like the tidyverse in R. Part of achieving that is making sure that tablecloth is rock solid, which just takes a lot of poking and prodding.</p><h2 id="london&#95;clojurians&#95;talk">London Clojurians talk</h2><p>This talk was a big inspiration for diving deep into Clojure's data science ecosystem. I experimented with a ton of different datasets for the workshop and discovered tons of potential areas for future development. Trying to put together a polished data workflow really exposed many of the key areas I think we should be focusing on and gave me a lot of inspiration for future work. I spent a ton of time exploring all of the possible ways to demonstrate a broad sample of data science tools and learned a lot along the way.</p><p>The resources from the talk are all available <a href='https://github.com/kiramclean/workshops/tree/main/london_clojurians_april_2024'>in this repo</a> and the video will be posted soon.</p><h2 id="summary&#95;of&#95;future&#95;work">Summary of future work</h2><p>I mentioned a few areas of focus above, below is a summary of the ongoing work as I see it. A framework for organizing this work is starting to emerge, and I've been thinking about in terms of four key areas:</p><h3 id="visualisation">Visualisation</h3><ul><li>Priority here is to release a stable dataviz API using the tools and wrappers we currently have so that we can start releasing guides and tutorials that follow a consistent style.</li><li>The long-term goal is to develop a robust, flexible, and stable data visualization library in Clojure itself based on the grammar of graphics.</li></ul><h3 id="machine&#95;learning">Machine learning</h3><ul><li>Priority is to decide which APIs we will commit to supporting in the long term and stabilize the "glue" libraries that provide the high-level APIs for data-first users.</li><li>Long term goal is to support the full spectrum of libraries and models that are in everyday use by data science professionals.</li></ul><h3 id="statistics">Statistics</h3><ul><li>Priority is to document the current options for accomplishing basic statistical modelling tasks, including Clojure libraries we do have, Java libs, and Python interop.</li><li>Long term goal is to have tablecloth-compatible stats libraries implemented in pure Clojure.</li></ul><h3 id="foundations">Foundations</h3><ul><li>Priority is to build a tidyverse for Clojure. This includes battle-testing tablecloth, fully documenting its capabilities, and fixing remaining, small, sharp edges.</li></ul><h2 id="going&#95;forward">Going forward</h2><p>My overarching goal (personally) is still to write a canonical resource for working with Clojure's data science stack (the Clojure Data Cookbook), and I'm still working on finding the right balance of documenting "work-in-progress" tools and libraries vs. delaying progress until I feel they are more "ready". Until now I've let the absence of stable or ideal APIs in certain areas hinder development of this book, but I'm starting to feel very confident in my understanding of the current direction of the ecosystem, enough so that I would feel good about releasing something a little bit more formal than a tutorial or guide and recommending usages with the caveat that development is ongoing in some areas. And while it will take a while to get where we want to go, I feel like I can finally see the path to getting there. It just takes a lot of work and lot of collaboration, but with your support we'll make it happen! Thanks for reading.</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-04-04-state-of-clojure-ml.html</id>
    <link href="https://codewithkira.com/2024-04-04-state-of-clojure-ml.html"/>
    <title>The Current State of ML in Clojure</title>
    <updated>2024-04-04T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>I had a really enlightening talk with <a href='https://www.linkedin.com/in/daniel-slutsky-42122b4/'>Daniel Slutsky</a> this week (who is an exceptional data scientist, software engineer, and community organizer I highly recommended meeting if you haven't already) about the current state of the machine learning landscape in Clojure. This post is my attempt to distill it into a summary for the community's benefit, so more people can understand where things are at and what the active developers in this space are working on.</p><p>It's no secret I love Clojure and especially working with data in Clojure, but it's fair to say that the Clojure for data science ecosystem is not anywhere near as easy to use or understand as reasonable potential users might expect. This is the main problem I'm focusing on this year, and there is significant effort being put into refining our tools to make them more accessible to a wider audience.</p><p>There are already people doing "real" machine learning work in Clojure, though, and below is an overview of what the current state of our libraries and tools are in that area, as of April 2024.</p><p><i>Update 2024-04-08: It's worth mentioning that deep learning and LLM libraries have been intentionally left out of this post in order to keep it a "reasonable" length. There is enough separate work happening in that space that it warrants its own, separate overview.</i></p><h2 id="summary">Summary</h2><p>There are a lot of links in this post. This table is an attempt to aggregate and summarize them. There are more details worth reading below, but in case you don't have time, this is the gist of it. To make a very long story short, current efforts are heavily focused on consolidating all of these amazing libraries into one (or at least a small number of clearly delineated ones) that is/are easy-to-use, providing a comphrehensive toolkit for doing machine learning in Clojure.</p><table><thead><tr><th>Category</th><th>Library</th><th>Description</th><th>License</th></tr></thead><tbody><tr><td><strong>Java ML Libraries</strong></td><td><a href='https://tribuo.org/'>Tribuo</a></td><td>A comprehensive Java ML framework, preferred library for ML workflows</td><td>Apache 2.0</td></tr><tr><td></td><td><a href='https://github.com/haifengl/smile'>Smile 2.x</a></td><td>Currently being phased out of main Clojure ML libraries</td><td>LGPL</td></tr><tr><td></td><td><a href='https://github.com/haifengl/smile'>Smile 3.x</a></td><td>Avoided due to licensing</td><td>GPL</td></tr><tr><td></td><td><a href='https://xgboost.readthedocs.io/en/stable/jvm/index.html'>XGBoost for JVM</a></td><td>Implements gradient boosting algorithms, can be used through Tribuo</td><td>Apache 2.0</td></tr><tr><td><strong>Clojure Wrappers</strong></td><td><a href='https://github.com/generateme/fastmath'>fastmath 2.4.0+</a></td><td>Clojure ML/stats library, dependency on Smile 2.x</td><td>MIT</td></tr><tr><td></td><td><a href='https://github.com/generateme/fastmath'>fastmath 3.x</a></td><td>Fastmath with no Smile dependency</td><td>MIT</td></tr><tr><td></td><td><a href='https://github.com/generateme/fastmath-clustering'>fastmath-clustering</a></td><td>Fastmath wrapper around Smile clustering, dependency on Smile 2.x</td><td>EPL-2.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/scicloj.ml.tribuo'>scicloj.ml.tribuo</a></td><td>Clojure wrapper for Tribuo, likely to become the main source for ML algorithms</td><td>EPL-1.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/scicloj.ml.smile'>scicloj.ml.smile</a></td><td>Clojure wrapper for more of Smile (than fastmath), likely to be deprecated due to licensing</td><td>EPL-2.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/scicloj.ml.xgboost'>scicloj.ml.xgboost</a></td><td>Clojure wrapper for XGBoost directly</td><td>EPL-1.0</td></tr><tr><td></td><td><a href='https://github.com/techascent/tech.ml.dataset'>tech.ml.dataset</a></td><td>Core dataframe/dataset library in Clojure, incorporates some Tribuo functionality</td><td>EPL-1.0</td></tr><tr><td></td><td><a href='https://github.com/techascent/tech.ml'>tech.ml</a></td><td>Early Clojure ML library, superceded by various scicloj.ml libraries</td><td>EPL-1.0</td></tr><tr><td><strong>Clojure ML Pipelines</strong></td><td><a href='https://github.com/scicloj/metamorph'>metamorph</a></td><td>Clojure function composition library</td><td>EPL-2.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/metamorph.ml'>metamorph.ml</a></td><td>Clojure library for composing ML pipelines based on metamorph</td><td>EPL-2.0</td></tr><tr><td><strong>Collections/Frameworks</strong></td><td><a href='https://github.com/scicloj/scicloj.ml'>scicloj.ml</a></td><td>Collection of Clojure ML libraries and documentation, being deprecated in favour of noj</td><td>EPL-2.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/noj'>noj</a></td><td><strong>Consolidated Clojure data science toolkit, likely to become the main, unified entry-point for Clojure's data science stack</strong></td><td>EPL-1.0</td></tr><tr><td><strong>Interop</strong></td><td><a href='https://github.com/cnuernber/libpython-clj'>libpython-clj</a></td><td>Python bindings for Clojure, enabling use of Python code and libraries directly from Clojure</td><td>EPL-2.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/sklearn-clj'>sklearn-clj</a></td><td>Utilizes libpython-clj for access to scikit-learn estimators and models from Clojure</td><td>EPL-1.0</td></tr><tr><td></td><td><a href='https://github.com/scicloj/clojisr'>clojisr</a></td><td>Bridge from Clojure to R, less relevance for ML compared to Python interop</td><td>EPL-2.0</td></tr></tbody></table><p>In addition to all of these libraries, the post mentions the <a href='https://clojurians.zulipchat.com/'>Clojurians Zulip</a>, the main Clojure-for-data-science community discussion forum, where main contributors to the ecosystem are active daily.<h2 id="java&#95;ml&#95;libraries">Java ML Libraries</h2></p><p>There are two (sort of four) popular Java libraries that implement many of the main algorithms and tools used in machine learning today (e.g. classification, regression, clustering, model development, etc.): <a href='https://tribuo.org/'>Tribuo</a> (including XGBoost, more on that in a second) and <a href='https://haifengl.github.io/'>Smile</a>. We count Smile as two libraries because Smile 2.x is LGPL-licensed, and Smile 3.x is GPL-licensed, which poses some potential conflicts for some end users. The community consensus is converging around moving away from Smile due to the GPL-relicensing issue, focusing instead on Tribuo and hand-rolled solutions.</p><p>There is also <a href='https://xgboost.readthedocs.io/en/stable/jvm/index.html'>XGBoost</a> for the JVM, mentioned above, which is an implementation of gradient boosting. XGBoost is a collection of algorithms whereas Tribuo is a more comprehensive framework (including things like data management, model evaluation, and experiment tracking). XGBoost can be used from Tribuo, so I don't exactly count it as a standalone library, although it can also be used in that way.</p><h2 id="clojure&#95;wrappers">Clojure wrappers</h2><p>There are two main "families" of libraries that wrap these Java ML libraries in Clojure.</p><p><a href='https://github.com/generateme/fastmath'>Fastmath</a> includes statistical as well as machine learning tools for Clojure. Fastmath 2.4.0+ depends on Smile 2, and the forthcoming fastmath 3.x will have no Smile dependency at all. The clustering functionality in fastmath 2.x that depended on smile has been moved to the <a href='https://github.com/generateme/fastmath-clustering'>fastmath-clustering</a> library, which will have a Smile 2.x dependency going forward. There is a strong preference in the community to avoid introducing GPL-licensed libraries into the ecosystem.</p><p>Clustering functionality will mostly be provided by <a href='https://github.com/scicloj/scicloj.ml.tribuo'>scicloj.ml.tribuo</a> going forward which, as you might expect, wraps the Tribuo Java library, and is likely to become the main source of ML algorithms for the ecosystem. This is one of a few libraries in the second family of libraries that wrap the Java libraries mentioned above. Other (self-explanatory) ones include <a href='https://github.com/scicloj/scicloj.ml.smile'>scicloj.ml.smile</a>, which wraps more of Smile than fastmath did (does), and <a href='https://github.com/scicloj/scicloj.ml.xgboost'>scicloj.ml.xgboost</a>.</p><p>It's also worth mentioning <a href='https://github.com/techascent/tech.ml.dataset'>tech.ml.dataset</a> (the core dataframe/dataset library underlying tablecloth), which <a href='https://github.com/techascent/tech.ml.dataset/blob/master/src/tech/v3/libs/tribuo.clj'>incorporates some of the functionality of tribuo</a>, with the API centred around individual datasets. There also used to be a library called <a href='https://github.com/techascent/tech.ml'>tech.ml</a>, which implements some machine learning tools, but has been deprecated in favour of the various libraries discussed above.</p><p>The concept of orienting an API around individual datasets vs something else leads me to the next group of libraries. </p><h2 id="clojure&#95;ml&#95;pipelines">Clojure ML Pipelines</h2><p><a href='https://github.com/scicloj/metamorph'>Metamorph</a> is a library that implements a function composition mechanism for composing ML pipelines. It arises from the common ML practice of repeatedly running the same set of functions with varied parameters. You might, for example, try many different test/train splits to see how that affects your results, or fit the same data using many different algorithms, or try training your model using different sets of features. This leads to an explosion of pipeline permutations, so it's useful to have machinery to encapsulate the variable components of your ML pipeline into a single function. This is where metamorph.ml comes in. </p><p><a href='https://github.com/scicloj/metamorph.ml'>Metamorph.ml</a> is based on this concept of meta-functions and pipelines. It is currently the central library for orchestrating ML pipelines in Clojure. The API is stable, but there are currently <a href='https://clojurians.zulipchat.com/#narrow/stream/321125-noj-dev/topic/ols.20interaction.20tutorial/near/422408507'>many ways (10+)</a> to achieve the same outcomes. This is great for power users who have complex needs and a clear understanding of the metamorph mental model, but it can be a bit daunting for newcomers, making it more challenging to pick a clear place to start. The community is actively discussing the best approach for consolidating and/or documenting these different approaches in the interest of making Clojure's ML stack more accessible.</p><h2 id="collections/frameworks">Collections/Frameworks</h2><p>The community is well aware that it is difficult to know where to get started and several efforts have been made in an attempt to make the path more clear for people who want tools that Just Work. <a href='https://github.com/scicloj/scicloj.ml'>scicloj.ml</a> is one such project. It's a collection of libraries (mostly the ones mentioned above) with some lightweight wrappers and efforts in creating documentation.</p><p>The community is heading toward deprecating this library, though, in favour of <a href='https://github.com/scicloj/noj'>noj</a>, which we are hoping to stabilize in the near future. The goal is to have a single entry-point into the Clojure data science stack, gathering all the tools one would need to work with data consolidated in one place, with seamless interoperability akin to R's tidyverse of libraries.</p><h2 id="interop">Interop</h2><p>It wouldn't be a complete roundup of the state of ML in Clojure without a mention of <a href='https://github.com/clj-python/libpython-clj'>libpython-clj</a>. This is a library that provides Python bindings for Clojure, so you can call Python code directly from Clojure if necessary. <a href='https://github.com/scicloj/sklearn-clj'>sklearn-clj</a> makes use of this bridge to provide direct access to all of the estimators and models from Python <a href='https://scikit-learn.org/'>scikit-learn</a> in Clojure, so for cases where something is truly only available in Python, we can still access it.</p><p>It's worth also briefly mentioning <a href='https://github.com/scicloj/clojisr'>clojisr</a> here, which is a similar kind of bridge from Clojure to R (and there exist libraries for Julia and Wolframite, too), but these are all less relevant for the specific area of ML, where Python is the overwhelmingly most popular current tool of choice.</p><h2 id="more&#95;updates">More updates</h2><p>These discussions all happen in the open, on the <a href='https://clojurians.zulipchat.com'>Clojurian's Zulip instance</a>, which has become the main gathering place of the Clojure-for-data-science community. The <code>#data-science</code> and <code>#noj-dev</code> streams are the most active on these topics at the time of this writing. You can follow along with developments in the trenches over there, or follow the key libraries on github for updates (<a href='https://github.com/scicloj/scicloj.ml.tribuo'>scicloj.ml.tribuo</a>, <a href='https://github.com/scicloj/metamorph.ml'>metamorph.ml</a>, <a href='https://github.com/scicloj/noj'>noj</a>). I will also post periodic updates here and all the other corners of the internet where I lurk. Thank you for reading!</p><p><strong>Discuss this post on <a href='https://news.ycombinator.com/item?id=39947045'>Hacker News</a> or <a href='https://www.reddit.com/r/Clojure/comments/1bxamkm/clojure_for_ml_update/'>Reddit</a></strong></p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-02-29-clojurists-together-update-jan-feb-2024.html</id>
    <link href="https://codewithkira.com/2024-02-29-clojurists-together-update-jan-feb-2024.html"/>
    <title>OSS Updates January and February 2024</title>
    <updated>2024-02-29T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>I was lucky enough to get funding this year from Clojurists together to work on some open source projects for the Clojure community. It's been a really fun couple of months getting more involved in the ecosystem and having the time to work on some projects that I've long thought would be valuable for the community. This post is a summary of the things I've been working on over the past two months.</p><h2 id="sponsors">Sponsors</h2><p>First of all, I want to thank the sponsors that make this work possible. We're living through the worst tech job market since I started working as a software engineer, and I'm lucky to have a little bit of time and runway to work on things I find interesting thanks to the generous sponsors who find my work worthwhile.</p><p>Right now my work is primarily funded by <a href='https://www.clojuriststogether.org'>Clojurists Together</a> and <a href='https://www.cognitect.com'>Cognitect/Nubank</a>. Thank you to these major sponsors, and to everyone who contributes to my continued work in the Clojure open source ecosystem.</p><p>If you find the work I do valuable, please share it with others or consider supporting it financially. I would love to be able to turn working on this kind of stuff into a sustainable career in the long term.</p><h2 id="clojure&#95;tidy&#95;tuesdays">Clojure Tidy Tuesdays</h2><p>The main thing I spent my time working on over the past couple of months was a collection of tutorials and guides for working with data in Clojure. The R for Data Science online learning community publishes toy datasets every week for "Tidy Tuesdays" with a question to answer or example article to reproduce. I've been going through them in Clojure, and it's proven a great tool for uncovering areas for future development in the Clojure data science ecosystem.</p><h2 id="other&#95;work">Other Work</h2><p>The explorations with the Tidy Tuesday data have been revealing areas where I think we could benefit from more ergonomic ways to work with tablecloth datasets. I started two little projects each with a couple of little wrappers around existing functions to make them easier to use with tablecloth datasets. So far I'm calling them <code>tcstats</code> (for statistical operations on datasets) and <code>tcutils</code> (with miscellaneous dataset manipulation tools that aren't built-in to tablecloth directly).</p><p>I am also still working on the Clojure Data Cookbook. I nudged it forward ever so slightly these last couple of months, and I plan to finish it despite the remaining holes in Clojure's data science stack. I would love to also fill these in eventually, but the Cookbook will be a living document that can easily evolve and be updated as new tools and libraries are developed.</p><p>Lastly, one of the main missing pieces I'm discovering we really need to work on in Clojure's data science ecosystem is a robust yet flexible graphics library. There are a few great solutions that already exist, but they take different approaches to graphing that can make them a bit clumsy to work with when it comes time to build more complex visualisations. My dream is to implement a proper <a href='https://ggplot2-book.org'>grammar of graphics</a> in Clojure, giving the Clojure data ecosystem a "professional quality" graphics library, so to speak. Anyway.. there is still tons of work to do here so I'm grateful for the ongoing funding that will allow me to continue to focus a large amount of time on it for the foreseeable future.</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-01-12-clojure-tidy-tuesdays.html</id>
    <link href="https://codewithkira.com/2024-01-12-clojure-tidy-tuesdays.html"/>
    <title>Clojure Tidy Tuesdays</title>
    <updated>2024-01-12T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>One of the things I'm going to spend my new-found independent software development time on this year is doing TidyTuesdays in Clojure. It's no surprise that I'm a big fan of Clojure, or that I think there is a lack of good "how to do data science with Clojure" content out there. One of the big things I want to accomplish this year is filling this gap.</p><p>To that end, I'll be publishing "translations" of the data-fetching scripts into Clojure and implementations of example data analysis from <a href='https://github.com/rfordatascience/tidytuesday/tree/master'>TidyTuesdays</a>, an initiative of the R for data science online learning community.</p><p>The idea is that they post a toy dataset each week along with an example article that uses the same or similar data, and then the community posts their solutions and what they did with it around the internet.</p><p>I'll be sharing mine in <a href='https://github.com/kiramclean/clojure-tidy-tuesdays/tree/main'>this Clojure Tidy Tuesdays github repo</a> and posting on <a href='https://indieweb.social/@kira'>Mastodon</a> and <a href='https://www.linkedin.com/in/kiramclean/'>LinkedIn</a>. Follow along here or there for more!</p>]]></content>
  </entry>
  <entry>
    <id>https://codewithkira.com/2024-01-02-a-year-of-open-source.html</id>
    <link href="https://codewithkira.com/2024-01-02-a-year-of-open-source.html"/>
    <title>A Year of Open Source</title>
    <updated>2024-01-02T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>It's a new year! I always feel so ambitious at the start of a new year. This one especially, though. I got a very exciting early Christmas present this year.</p><p><img src="/assets/2024-01-02-clj-together-message.jpg" alt="Daniel's very exciting message!" /></p><p>Of course I happily accepted this super exciting opportunity. Ever since I started dabbling software nearly 10 years ago now my dream was to eventually someday, somehow, make a living on my own terms. I quickly learned that I am not cut out for tech startups, but there are lots of other ways to make a living in software. I'm not sure I'm cut out for those either, but the way I see it this year is my chance to finally find out.</p><p>I'm mostly optimistic. I definitely have tons of ideas for things to work on, and I have a ton of motivation to make this work. How amazing would it be to actually be able to make a sustainable living working on things that I find interesting and that benefit my community? I'm planning on giving myself this year to make it work, and if I have to I'll find a real job again next year. I hope I don't have to.</p><p>I'll be working on open source projects using Clojure, mostly focusing on data-related stuff. I have a long running project writing a book about doing data stuff in Clojure that I plan to spend a lot more time on this year. It turns out writing a book is <i>so much</i> work, way more than I thought at first, but I'm never giving up and I will finish it no matter how long it takes. I also have a million small ideas for polishing things around the clojure data ecosystem that I think would help make it feel more ergonomic for "data people". I'd love to build on some of the tools out there for combining data libraries, tidyverse style. There's also a lack of guides and courses for learning how to use the emerging "default" stack for data science in Clojure. I think I can help in all these areas.</p><p>I think it'll take some discipline and re-wiring of my brain to be successful, but I think I can do it. I'm so used to being given projects to do for other people and squeezing in my side projects around my working hours. What will it look like when my side projects become my main focus during full-time working hours?</p><p>I'll need to learn how to prioritize things without much external influence or direction. Case in point &ndash; I spent over an hour faffing with the styles for this blog. On one hand, I care more than I should about aesthetics and at the end of the day do believe that function should take priority. On the other hand, it's done now and I have a blog I like looking at!</p><p>Anyway I made this website to separate my work in programming from my other pursuits, like yoga and violin. My plan is to post periodic updates and other tech-related posts here. If there's anything you would like to see contributed to the Clojure ecosystem, let me know! I'm always open to suggestions and ideas and especially early on this year I would love to hear from the people who voted for me to receive this funding.</p><p>Wish me luck!</p>]]></content>
  </entry>
</feed>
